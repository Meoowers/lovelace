; Imports to all of the categories

(require "./src/std.lisp")
(require "./src/compiler/env.lisp")
(require "./src/compiler/lexer.lisp")
(require "./src/compiler/parser.lisp")
(require "./src/compiler/specialize.lisp")

(set* code "(set* lovelace/between (fn lovelace/between (min-num max-num) (block (fn (node span) (let ((node-length (length node))) (if (if (< node-length min-num) :true (if (> node-length max-num) :true :false)) (block (throw (concat \"expected between \" (string min-num) \" and \" (string max-num) \" arguments but got \" (string node-length)) span)))))))) (set* lovelace/at-least (fn lovelace/at-least (num) (block (fn (node span) (if (< (length node) num) (block (throw (concat \"expected at least \" (string num) \" arguments but got \" (string (length node))) span))))))) (set* lovelace/exact (fn lovelace/exact (num) (block (fn (node span) (if (!= (length node) num) (block (throw (concat \"expected \" (string num) \" arguments but got \" (string (length node))) span))))))) (set* lovelace/args (fn lovelace/args (node fun) (block (check node \"list\") (apply fun (list node (span node))) node))) (set* lovelace/specialize/let (fn lovelace/specialize/let (node) (block (lovelace/args node (lovelace/at-least 3)) (check (at node 1) \"list\") (list/foreach (at node 1) (fn (arg) (block (check arg \"list\") (lovelace/args arg (lovelace/exact 2)) (check (at arg 0) \"identifier\") (lovelace/specialize (at arg 1))))) (list/foreach (at (list/split node 2) 1) lovelace/specialize)))) (set* lovelace/specialize/set* (fn lovelace/specialize/set* (node) (block (lovelace/args node (lovelace/exact 3)) (lovelace/specialize (at node 2))))) (set* lovelace/specialize/block (fn lovelace/specialize/block (node) (block (lovelace/args node (lovelace/at-least 2)) (list/foreach (at (list/split node 2) 1) lovelace/specialize)))) (set* lovelace/specialize/set (fn lovelace/specialize/set (node) (block (lovelace/args node (lovelace/exact 3)) (lovelace/specialize (at node 2))))) (set* lovelace/specialize/quote (fn lovelace/specialize/quote (node) (block (lovelace/args node (lovelace/exact 2)) (lovelace/specialize (at node 1))))) (set* lovelace/specialize/while (fn lovelace/specialize/while (node) (block (lovelace/args node (lovelace/at-least 2)) (let ((condition (lovelace/specialize (at node 1))) (body (at (list/split node 2) 1))) (concat (list (quote while)) (list condition) (list/map body lovelace/specialize)))))) (set* lovelace/specialize/while (fn lovelace/specialize/while (node) (block (lovelace/args node (lovelace/at-least 2)) (lovelace/specialize (at node 1)) (list/foreach (at (list/split node 2) 1) lovelace/specialize)))) (set* lovelace/specialize/macro (fn lovelace/specialize/macro (node) (block (lovelace/args node (lovelace/exact 2))))) (set* lovelace/specialize/if (fn lovelace/specialize/if (node) (block (lovelace/args node (lovelace/between 3 4)) (lovelace/specialize (at node 1)) (lovelace/specialize (at node 2)) (if (not (nil? (at node 3))) (lovelace/specialize (at node 3)))))) (set* lovelace/specialize/fn (fn lovelace/specialize/fn (node) (block (lovelace/args node (lovelace/at-least 3)) (let ((labeled? (identifier? (at node 1))) (label (if labeled? (at node 1) (quote nil-label))) (params (if labeled? (at node 2) (at node 1))) (body (if labeled? (at node 3) (at node 2)))) (check label \"identifier\") (list/foreach params (fn (param) (check param \"identifier\"))) (list/foreach body lovelace/specialize))))) (set* lovelace/specialize (fn lovelace/specialize (node) (block (let ((_condition_ (type node))) (if (= _condition_ \"list\") (block (if (= 0 (length node)) node (let ((fst (head node))) (if (= fst (quote let)) (lovelace/specialize/let node) (if (= fst (quote block)) (lovelace/specialize/block node) (if (= fst (quote set*)) (lovelace/specialize/set* node) (if (= fst (quote set)) (lovelace/specialize/set node) (if (= fst (quote fn)) (lovelace/specialize/fn node) (if (= fst (quote quote)) (lovelace/specialize/quote node) (if (= fst (quote while)) (lovelace/specialize/while node) (if (= fst (quote if)) (lovelace/specialize/if node) (if (= fst (quote macro)) (lovelace/specialize/macro node) (if :true (cons fst (list/map (tail node) lovelace/specialize)) (throw (concat \"cond: no match\"))))))))))))))) (if (= _condition_ \"identifier\") (block node) (if (= _condition_ \"atom\") (block node) (if (= _condition_ \"number\") (block node) (if (= _condition_ \"string\") (block node) (throw (concat \"switch: no match \" (string (type node))) (quote (3149 3160))))))))))))")

(defn at-inv (x arr)
    (at arr x))

(set* m (|> code
    lovelace/tokenize
    lovelace/parse))

(list/foreach m lovelace/specialize)